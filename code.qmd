---
title: "Analysis of Natural Resources and Conflict Clustering"
author: "Ann Lian"
format: html
toc: true
execute:
  warning: false
  echo: true
  message: false
editor: 
  markdown: 
    wrap: sentence
---

# Introduction

This project analyzes the relationship between international conflicts and natural resources.

------------------------------------------------------------------------

# Data and Methods

## Overview of Conflict Dataset

```{r, echo=TRUE, message=FALSE, warning=FALSE}
# Load libraries
library(sf)
library(sp)
library(spdep)
library(tmap)
library(tidyverse)
library(pbapply)
library(ggplot2)
library(rnaturalearth)
library(rnaturalearthdata)
library(stringr)
library(maps)
library(leaflet)
library(spatstat)

# Load conflict dataset
conflict_data <- read.csv("data/conflict_data_22_24.csv")

# Display summary
cat("Number of Rows: ", nrow(conflict_data), "\n")
cat("Number of Columns: ", ncol(conflict_data), "\n")
cat("Column Names: \n", colnames(conflict_data), "\n")
cat("\nFirst 5 Rows:\n")
print(head(conflict_data, 5))
```


## Choropleth Map of Conflict Fatalities

```{r, echo=TRUE, message=FALSE}
# Aggregate and plot map
world_map <- map_data("world")
country_data <- conflict_data %>%
  group_by(country) %>%
  summarise(total_fatalities = sum(fatalities, na.rm = TRUE))

world_map <- world_map %>%
  mutate(region = tolower(region))
country_data <- country_data %>%
  mutate(country = tolower(country))

map_data <- world_map %>%
  left_join(country_data, by = c("region" = "country"))

ggplot(map_data, aes(x = long, y = lat, group = group, fill = total_fatalities)) +
  geom_polygon(color = "gray90", size = 0.1) +
  scale_fill_gradient(low = "lightblue", high = "darkred", na.value = "white", name = "Fatalities") +
  theme_minimal() +
  labs(
    title = "Choropleth Map of Conflict Fatalities (2022-2024)",
    x = "Longitude",
    y = "Latitude"
  ) +
  coord_fixed(1.3)
```


## Overview of Resource Dataset

```{r, echo=TRUE, messge=FALSE}
# Load resources dataset
resources_data <- read.csv("data/global_power_plant_database.csv")

# Select required variables
resources_data <- dplyr::select(resources_data, country, country_long, capacity_mw, latitude, longitude, primary_fuel)

# Display summary
cat("Number of Rows: ", nrow(resources_data), "\n")
cat("Number of Columns: ", ncol(resources_data), "\n")
cat("Column Names: \n", colnames(resources_data), "\n")
cat("\nFirst 5 Rows:\n")
print(head(resources_data, 5))
```

## Point Map of Resources

```{r, echo=TRUE}
# Plot the world map with power plant locations
ggplot() +
  geom_polygon(data = world_map, aes(x = long, y = lat, group = group), fill = "gray90", color = "gray50") +
  geom_point(data = resources_data, aes(x = longitude, y = latitude, color = primary_fuel), alpha = 0.7, size = 1) +
  theme_minimal() +
  labs(
    title = "Global Power Plant Locations",
    x = "Longitude",
    y = "Latitude",
    color = "Fuel Type"
  ) +
  coord_fixed(1.3)
```


------------------------------------------------------------------------

# Spatial Analysis

## Moran’s I

### Global Moran’s I of Conflicts

```{r, echo=TRUE, message=FALSE}
# Convert data to spatial object
conflict_sf <- st_as_sf(conflict_data, coords = c("longitude", "latitude"), crs = 4326)
conflict_sf <- st_transform(conflict_sf, crs = 3857)

# Aggregate by grid cells
grid <- st_make_grid(conflict_sf, cellsize = 50000)
grid <- st_sf(grid_id = 1:length(grid), geometry = st_sfc(grid))
grid_aggregated <- st_join(conflict_sf, grid) %>%
  group_by(grid_id) %>%
  summarise(total_fatalities = sum(fatalities, na.rm = TRUE))

# Compute Moran's I
centroids <- st_centroid(grid_aggregated)
coords_conflict <- st_coordinates(centroids)
dist_matrix_conflict <- dnearneigh(coords_conflict, 0, 500000)
weights_conflict <- nb2listw(dist_matrix_conflict, style = "B", zero.policy = TRUE)
global_moran_conflict <- moran.test(grid_aggregated$total_fatalities, weights_conflict, zero.policy = TRUE)
print(global_moran_conflict)
```


### Local Moran’s I of Conflicts

```{r, echo=TRUE, message=FALSE}
# Compute Local Moran's I
local_moran <- localmoran(grid_aggregated$total_fatalities, weights_conflict, zero.policy = TRUE)

grid_aggregated$local_moran <- local_moran[, 1]
grid_aggregated$p_value <- local_moran[, 5]
grid_aggregated$significance <- grid_aggregated$p_value < 0.05
grid_aggregated$cluster_type <- case_when(
  local_moran[, 1] > 0 & grid_aggregated$significance ~ "High-High",
  local_moran[, 1] < 0 & grid_aggregated$significance ~ "Low-Low",
  TRUE ~ "Not Significant"
)
summary(grid_aggregated)
```


**Visualization**

```{r, echo = TRUE}
# Visualize the clusters
tmap_mode("view")
tm <- tm_shape(grid_aggregated) +
  tm_dots(
    col = "cluster_type",
    palette = c("red", "blue", "gray"),
    title = "Cluster Type",
    alpha = 0.7
  ) +
  tm_layout(legend.outside = TRUE)

# Save the map
tmap_save(tm, "conflict_clusters_map.html")

# Display plot
tmap_mode("plot")
tm
```

[View the interactive map here](conflict_clusters_map.html)


### Global Moran’s I of Resources

```{r, echo=TRUE, message=FALSE}
# Convert data to spatial object
resources_sf <- st_as_sf(resources_data, coords = c("longitude", "latitude"), crs = 4326)
# Reproject to a metric CRS
resources_sf <- st_transform(resources_sf, crs = 3857)

# Create a distance matrix for resources (500-km radius)
coords <- st_coordinates(resources_sf)
dist_matrix <- dnearneigh(coords, 0, 500000) # 500 km

# Convert to spatial weights
weights <- nb2listw(dist_matrix, style = "B", zero.policy = TRUE)

# Ensure no missing values in the variable
resources_sf$capacity_mw <- as.numeric(resources_sf$capacity_mw)
resources_sf <- resources_sf[!is.na(resources_sf$capacity_mw), ]

# Global Moran's I
global_moran <- moran.test(resources_sf$capacity_mw, weights, zero.policy = TRUE)

# Output results
print(global_moran)
```


### Local Moran’s I of Resources

```{r, echo=TRUE, message=FALSE}
# Compute Local Moran's I
local_moran <- localmoran(resources_sf$capacity_mw, weights, zero.policy = TRUE)

# Add Local Moran's I results to the spatial data
resources_sf$local_moran <- local_moran[, 1] # Local Moran's I statistic
resources_sf$p_value <- local_moran[, 5] # p-values
resources_sf$significance <- resources_sf$p_value < 0.05 # Significant clusters (p < 0.05)

# Classify Results
resources_sf$cluster_type <- with(resources_sf, ifelse(
  significance & local_moran > 0, "High-High", # High values surrounded by high values
  ifelse(significance & local_moran < 0, "Low-Low", # Low values surrounded by low values
         ifelse(significance, "Outlier", "Not Significant")) # Outliers or not significant
))

```

**Visualization**

```{r, echo=TRUE}
# Visualization of Local Moran's I
tmap_mode("view")

tm_re <- tm_shape(resources_sf) +
  tm_dots(col = "cluster_type", palette = c("red", "blue", "purple", "gray"), 
          title = "Cluster Type", labels = c("High-High", "Low-Low", "Outlier", "Not Significant")) +
  tm_layout(legend.outside = TRUE)

# Save the map
tmap_save(tm_re, "resources_clusters_map.html")

# Display plot
tmap_mode("plot")
tm_re
```

[View the interactive map here](resources_clusters_map.html)


### Compare conflict and resource data


```{r, echo=TRUE}

# Spatial Join: Associate conflicts with resource clusters
conflict_with_clusters <- st_join(conflict_sf, resources_sf, left = FALSE)

# Summarize the number of conflicts per cluster type
conflict_summary <- conflict_with_clusters %>%
  group_by(cluster_type) %>%
  summarise(conflict_count = n()) %>%
  mutate(percentage = conflict_count / sum(conflict_count) * 100)

# Display the results
print(conflict_summary)

```


## Pairwise Correlation Function (PCF)

### PCF of Observed Data

```{r, echo=TRUE}
# Keep geometry and create a "type" column
resources_sf <- resources_sf %>%
  dplyr::select(geometry) %>% 
  mutate(type = "resource")

conflict_sf <- conflict_sf %>%
  dplyr::select(geometry) %>%
  mutate(type = "conflict")

# Sample data
resources_sampled <- resources_sf %>% slice_sample(n = 10000)
conflicts_sampled <- conflict_sf %>% slice_sample(n = 10000)

# Combine the datasets
combined_sf <- rbind(resources_sampled, conflicts_sampled)

# Convert to a ppp object
combined_ppp <- as.ppp(st_geometry(combined_sf))

# Ensure the `type` column is a factor
combined_sf$type <- as.factor(combined_sf$type)
# Add marks (types) to the ppp object
marks(combined_ppp) <- combined_sf$type


# Compute the Pairwise Correlation Function (PCF)
# From 0 to 100 km, in steps of 5 km
pcf_observed <- pcfcross(combined_ppp, i = "resource", j = "conflict", r = seq(0, 100000, by = 5000))

# Visualize the PCF
plot(
  pcf_observed,
  main = "Observed Pairwise Correlation Function (PCF)",
  xlab = "Distance (meters)",
  ylab = "PCF",
  col = "blue"
)
abline(h = 1, col = "red", lty = 2, lwd = 1.5)
```


### PCF for Simulation

```{r, echo=TRUE}
# simulation
simulated_pcfs <- envelope(
  combined_ppp,
  pcfcross,
  nsim = 999,
  i = "resource",
  j = "conflict",
  r = seq(0, 100000, by = 1000),  # Up to 100 km
  verbose = FALSE
)

# Plot PCF with confidence envelopes
plot(
  simulated_pcfs,
  main = "PCF with Monte Carlo Confidence Envelope",
  xlab = "Distance (meters)",
  ylab = "PCF"
)

# Extract distances
r_values <- simulated_pcfs$r

# Extract observed PCF
observed_pcf <- simulated_pcfs$obs

# Extract lower and upper confidence bounds
lower_bound <- simulated_pcfs$lo
upper_bound <- simulated_pcfs$hi

# Extract theoretical PCF
theoretical_pcf <- simulated_pcfs$theo

# Combine into a data frame
pcf_summary <- data.frame(
  Distance = r_values,
  Observed = observed_pcf,
  Theoretical = theoretical_pcf,
  LowerBound = lower_bound,
  UpperBound = upper_bound
)

# View summary of the PCF data
summary(pcf_summary)

```


### Compare PCF of Observed Data and Simulation

```{r, echo=TRUE}
# Remove Inf and NA from pcf_summary
pcf_summary_clean <- pcf_summary[is.finite(pcf_summary$Observed) & 
                                   is.finite(pcf_summary$LowerBound) & 
                                   is.finite(pcf_summary$UpperBound), ]

# Remove Inf from pcf_observed
pcf_observed_clean <- pcf_observed[is.finite(pcf_observed$trans) & 
                                     is.finite(pcf_observed$iso), ]


# Merge observed and simulation summaries by Distance
comparison <- merge(
  pcf_summary_clean[, c("Distance", "Observed", "LowerBound", "UpperBound")], 
  pcf_observed_clean[, c("r", "trans", "iso")], 
  by.x = "Distance", by.y = "r", 
  all = TRUE
)

# View comparison table
summary(comparison)

```

**Visulization**

```{r, echo=TRUE}
# Plot observed PCF with confidence bounds
plot(
  comparison$Distance, comparison$Observed,
  type = "l", col = "blue", lwd = 2, ylim = c(0, max(comparison$UpperBound, na.rm = TRUE)),
  xlab = "Distance (meters)", ylab = "PCF",
  main = "Observed PCF vs Monte Carlo Confidence Envelope"
)

# Add confidence bounds
lines(comparison$Distance, comparison$LowerBound, col = "gray", lty = 3)
lines(comparison$Distance, comparison$UpperBound, col = "gray", lty = 3)

# Highlight significant clustering
significant_points <- comparison[comparison$Observed > comparison$UpperBound, ]
points(significant_points$Distance, significant_points$Observed, col = "purple", pch = 8)

# Add legend
legend("topright", legend = c("Observed PCF", "Confidence Envelope", "Significant Clustering"),
       col = c("blue", "gray", "purple"), lty = c(1, 3, NA), pch = c(NA, NA, 8))
```

------------------------------------------------------------------------

# References

-   ACLED Data: https://acleddata.com
-   Global Power Plant Database: https://resourcewatch.org
